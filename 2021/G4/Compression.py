from Intercom_buffer import Intercom_buffer
import sounddevice as sd
import numpy as np
import psutil
import time
import zlib



# Accumulated percentage of used CPU. 
CPU_total = 0

# Number of samples of the CPU usage.
CPU_samples = 0

# CPU usage average.
CPU_average = 0

class Compression(Intercom_buffer):
#-----------------------------------------------------------------------------------------------    
    def init(self, args):
        Intercom_buffer.init(self, args)
    #Pack y unpack de zlib
    def pack(self,chunk):
        cchunk = zlib.compress(chunk,level=5)
        return cchunk
    def unpack(self,chunk):
        uchunk = zlib.decompress(chunk)
        return uchunk
#-------------------------------------------------------------------------------------------------------------
    # Waits for a new chunk and insert it into the right position of
    # the buffer. As the receive_and_queue() method in
    # Intercom_minimal, this method is called from an infinite loop.
    def receive_and_buffer(self):
        message = super().receive()
        #Desempacamos el mensaje
        message = self.unpack(message)
        (chunk_number,) = np.frombuffer(message[:2],dtype='>H')
        chunk = np.frombuffer(message[2:], np.int16).reshape(self.frames_per_chunk, self.number_of_channels)
        self._buffer[chunk_number % self.cells_in_buffer] = chunk
        return chunk_number
    
    def record_send_and_play(self, indata, outdata, frames, time, status):
        self.recorded_chunk_number = (self.recorded_chunk_number + 1) % self.CHUNK_NUMBERS
        #Metemos el mensaje y el numero de chunk en el mismo paquete
        #Codificamos los primeros 2 bytes correspondientes a 
        #el numero de chunk
        chunk = np.array(self.recorded_chunk_number,dtype='>H').tobytes() + indata.tobytes()
        #Empacamos el mensaje
        chunk = self.pack(chunk)
        #enviamos el paquete
        super().send_chunk(chunk)
        super().play_chunk(outdata)
  
    def run(self):
         # Buffer creation.
        self._buffer = [None] * self.cells_in_buffer
        for i in range(self.cells_in_buffer):
            self._buffer[i] = self.empty_chunk

        # Chunks counters.
        self.recorded_chunk_number = 0
        self.played_chunk_number = 0

        print("Compression: press <CTRL> + <c> to quit")
        print("Compression: buffering ... ")

        with sd.Stream(samplerate=self.frames_per_second, blocksize=self.frames_per_chunk, dtype=self.sample_type, channels=self.number_of_channels, callback=self.record_send_and_play):
            first_received_chunk_number = self.receive_and_buffer()
            self.played_chunk_number = (first_received_chunk_number - self.chunks_to_buffer) % self.cells_in_buffer
            while True:
                self.receive_and_buffer()

    # Shows CPU usage.
    def print_feedback_message(self):
        # Be careful, variables updated only in the subprocess.
        global CPU_total
        global CPU_samples
        global CPU_average
        CPU_usage = psutil.cpu_percent()
        CPU_total += CPU_usage
        CPU_samples += 1
        CPU_average = CPU_total/CPU_samples
        print(f"{int(CPU_usage)}/{int(CPU_average)}", flush=True, end=' ')

    # This method runs in a different process to the intercom, and its
    # only task is to print the feedback messages with the CPU load,
    # waiting for the interrupt signal generated by the user (CTRL+C).
    def feedback(self):
        global CPU_average
        try:
            while True:
                self.print_feedback_message()
                time.sleep(1)
        except KeyboardInterrupt:
            print(f"\nIntercom_buffer: average CPU usage = {CPU_average} %")


if __name__ == "__main__":
    intercom = Compression()
    parser = intercom.add_args()
    args = parser.parse_args()
    intercom.init(args)
    try:
        intercom.run()
    except KeyboardInterrupt:
        print("Intercom_buffer: goodbye 2020¯\_(ツ)_/¯")

